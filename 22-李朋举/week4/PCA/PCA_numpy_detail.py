# -*- coding: utf-8 -*-
"""
使用PCA求样本矩阵X的K阶降维矩阵Z
"""

import numpy as np


class CPCA(object):
    """用PCA求样本矩阵X的K阶降维矩阵Z
    Note:请保证输入的样本矩阵X shape=(m, n)，m行样例，n个特征
    """

    def __init__(self, X, K):
        """
        :param X,样本矩阵X
        :param K,X的降维矩阵的阶数，即X要特征降维成k阶
        """
        self.X = X  # 样本矩阵X
        self.K = K  # K阶降维矩阵的K值
        self.centrX = []  # 矩阵X的中心化
        self.C = []  # 样本集的协方差矩阵C
        self.U = []  # 样本矩阵X的降维转换矩阵
        self.Z = []  # 样本矩阵X的降维矩阵Z

        self.centrX = self._centralized()  # 矩阵X的中心化
        self.C = self._cov()  # 求样本矩阵X的协方差矩阵C
        self.U = self._U()  # 求X的降维转换矩阵U
        self.Z = self._Z()  # 按照Z=XU求降维矩阵Z

    def _centralized(self):
        """矩阵X的中心化"""
        print('样本矩阵X:\n', self.X)
        centrX = []
        """ 样本集的特征均值
            循环处理,使用了NumPy库来计算样本集中每个特征的均值
            首先对样本集进行转置（使用self.X.T），然后对转置后的每一列（即每个特征）分别计算均值，最终将这些均值存储在一个名为mean的NumPy数组中。
                self.X.T：首先，self.X 是一个包含样本集的数组，.T 表示对该数组进行转置操作，即将行和列互换，这样可以使得每一列代表一个特征。
                np.mean(attr) 是使用 NumPy 库中的函数来计算数组 attr 的均值。具体来说，np.mean() 函数会接受一个数组作为输入，然后计算该数组中所有元素的平均值。
                [np.mean(attr) for attr in self.X.T]：这是一个列表推导式，它遍历了转置后的数组的每一列（即每个特征），
                                                      对每一列使用np.mean()函数来计算均值，然后将结果存储在一个列表中。
                numpy.array(object)  作用：创建一个数组。
        """
        mean = np.array([np.mean(attr) for attr in self.X.T])
        print('self.X.T:\n', self.X.T)
        '''
            self.X.T:
                 [[10 15 23 11 42  9 11  8 11 21]    # 均值 16.1
                 [15 46 21  9 45 48 21  5 12 20]     # 均值 24.2
                 [29 13 30 35 11  5 14 15 21 25]]    # 均值 19.8
        '''
        print('样本集的特征均值:\n', mean)
        '''
            样本集的特征均值: [16.1 24.2 19.8]
        '''
        """"
        centrX = self.X - mean，它的作用是将样本集中的每个样本都减去对应特征的均值，从而实现数据的中心化处理。
        self.X 是一个包含多个样本的矩阵，每一行代表一个样本，每一列代表一个特征，而 mean 是之前计算得到的特征均值数组。
        那么 self.X - mean 将会对 self.X 中的每个元素都分别减去 mean 中对应位置的值，得到中心化后的样本集 centrX。
        中心化的过程可以帮助消除不同特征之间的量纲差异，使得数据更加符合某些模型的假设，或者更容易进行特征分析和可视化。
        """
        centrX = self.X - mean  ##样本集的中心化
        print('样本矩阵X的中心化centrX:\n', centrX)
        ''''
        样本矩阵X的中心化centrX:
        # 原[10, 15, 29] 减对应 特征均值[16.1 24.2 19.8] = [ -6.1  -9.2   9.2]
                 [[ -6.1  -9.2   9.2]
                 [ -1.1  21.8  -6.8]
                 [  6.9  -3.2  10.2]
                 [ -5.1 -15.2  15.2]
                 [ 25.9  20.8  -8.8]
                 [ -7.1  23.8 -14.8]
                 [ -5.1  -3.2  -5.8]
                 [ -8.1 -19.2  -4.8]
                 [ -5.1 -12.2   1.2]
                 [  4.9  -4.2   5.2]]
        '''
        return centrX

    def _cov(self):
        """求样本矩阵X的协方差矩阵C"""
        # 样本集的样例总数
        ns = np.shape(self.centrX)[0]
        print('样本集的样例总数', ns)   # 10
        # 样本矩阵的协方差矩阵C
        ''''
        D = Z(T)*Z / m  计算中心化后的样本集的协方差矩阵（描述了不同特征之间的相关性和方差）
        使用NumPy 库中的 np.dot() 函数来计算中心化后的样本集的协方差矩阵。
                  具体来说，self.centrX 是已经中心化（减去均值）的样本集，self.centrX.T 是它的转置，而 ns 则是样本数量。
        np.dot(self.centrX.T, self.centrX) 实际上进行了矩阵乘法运算，得到了中心化后的样本集的协方差矩阵。最后除以 (ns - 1) 是为了得到协方差的无偏估计。
        '''
        C = np.dot(self.centrX.T, self.centrX) / (ns - 1)
        print('样本矩阵X的中心化centrX的转置:\n',self.centrX.T)
        ''''
        样本矩阵X的中心化centrX的转置 self.centrX.T :
                 [[ -6.1  -1.1   6.9  -5.1  25.9  -7.1  -5.1  -8.1  -5.1   4.9]
                 [ -9.2  21.8  -3.2 -15.2  20.8  23.8  -3.2 -19.2 -12.2  -4.2]
                 [  9.2  -6.8  10.2  15.2  -8.8 -14.8  -5.8  -4.8   1.2   5.2]]
        '''
        print('样本矩阵X的协方差矩阵C:\n', C)
        ''''
        np.dot()函数主要有两个功能，向量点积和矩阵乘法
        centrX * centrX.T /  (ns - 1)
        样本矩阵X的协方差矩阵C:
             [[ 108.32222222   74.53333333     -10.08888889]
             [  74.53333333    260.62222222    -106.4      ]
             [ -10.08888889    -106.4          94.17777778]]
        '''
        return C

    def _U(self):
        """求X的降维转换矩阵U, shape=(n,k), n是X的特征维度总数，k是降维矩阵的特征维度"""
        # 先求X的协方差矩阵C的特征值和特征向量
        ''''
        使用NumPy 库中的 np.linalg.eig() 函数来计算矩阵 self.C 的特征值和特征向量。
        具体来说，np.linalg.eig() 函数接受一个方阵作为输入，然后返回两个值：一个包含该矩阵的特征值的数组，和一个包含该矩阵的特征向量的二维数组。
                np.linalg.eig(self.C) 返回的特征值被赋值给变量 a，而特征向量被赋值给变量 b。
                这段代码通常用于在线性代数和特征分解相关的计算中，特征值和特征向量是很重要的概念。通过计算特征值和特征向量，我们可以了解矩阵的性质和行为。
        '''
        a, b = np.linalg.eig(self.C)
        # 特征值赋值给a，对应特征向量赋值给b。函数doc：https://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.linalg.eig.html
        print('样本集的协方差矩阵C的特征值:\n', a)
        ''''
        样本集的协方差矩阵C的特征值:
            [335.15738485  95.32771231  32.63712506]
        '''
        print('样本集的协方差矩阵C的特征向量:\n', b)
        '''
        样本集的协方差矩阵C的特征向量:
             [[-0.30253213 -0.87499307 -0.37797014]
             [-0.86718533  0.08811216  0.49012839]
             [ 0.39555518 -0.47604975  0.78543792]]
        '''
        # 给出特征值降序(-1)的topK的索引序列
        '''
        使用NumPy 库中的 argsort 函数来对数组 a 进行排序，并返回排序后的索引值。
           在这里，-1 * a 表示对数组 a 中的元素取负值，然后再进行排序，即按照元素的负值进行降序排序。
           假设数组 a 的值为 [3, 1, 2]，那么-1 * a 的值为 [-3, -1, -2]。然后，np.argsort(-1 * a) 将返回排序后的索引值，即 [0, 2, 1]，
           表示按照 -1 * a 的值进行降序排序后，原始数组中的元素索引为 0 的元素最大，索引为 2 的元素次之，索引为 1 的元素最小。
        这行代码的作用是获取数组 a 中元素按照负值降序排列的索引，这在很多排序和排名的应用中都非常有用。
        '''
        ind = np.argsort(-1 * a)
        print("排序后的索引值ind",ind)  # [0 1 2]
        # 构建K阶降维的降维转换矩阵U
        '''
        使用列表推导式构建一个名为 UT 的列表。b 应该是一个二维数组->特征向量，ind 是一个索引数组->给出特征值降序(-1)的topK的索引序列，self.K是K阶降维矩阵的K值 ->2维度。
        UT 列表中的每个元素都是通过对数组 b 的列进行切片得到的。具体来说，对于每个 i，b[:, ind[i]] 表示取数组 b 的所有行，以及索引数组 ind 中第 i 个元素所指定的列。
        这样就构成了 UT 列表，其中每个元素都是一个包含特定列数据的一维数组。
        '''
        UT = [b[:, ind[i]] for i in range(self.K)]  # range(self.K) 会生成一个包含 0 和 1 的整数序列。 取b的第0列和第1列
        print('UT 的列表:\n', UT)
        # [array([-0.30253213, -0.86718533,  0.39555518]),
        #  array([-0.87499307,  0.08811216, -0.47604975])]
        '''
        使用NumPy 库中的 np.transpose 函数来对矩阵进行转置操作。在这里，假设 UT 是一个矩阵，np.transpose(UT) 将返回 UT 的转置矩阵。
           转置操作会将矩阵的行和列互换，即原矩阵的第 i 行会变成转置矩阵的第 i 列，原矩阵的第 j 列会变成转置矩阵的第 j 行。
           因此，对于给定的矩阵 UT，U = np.transpose(UT) 将得到 U，U 是 UT 的转置矩阵。
        '''
        U = np.transpose(UT)
        print('%d阶降维转换矩阵U:\n' % self.K, U)
        '''
        2阶降维转换矩阵U:
             [[-0.30253213 -0.87499307]
             [-0.86718533  0.08811216]
             [ 0.39555518 -0.47604975]]
        '''
        return U

    def _Z(self):
        """按照Z=XU求降维矩阵Z, shape=(m,k), n是样本总数，k是降维矩阵中特征维度总数"""
        Z = np.dot(self.X, self.U)
        print('X shape:', np.shape(self.X))
        print('U shape:', np.shape(self.U))
        print('Z shape:', np.shape(Z))
        print('样本矩阵X的降维矩阵Z:\n', Z)
        '''
        X shape: (10, 3)
        U shape: (3, 2)
        Z shape: (10, 2)
        
        样本矩阵X的降维矩阵Z:
             [[ -4.56200104 -21.2336912 ]
             [-39.28629002 -15.26038349]
             [-13.30247561 -32.55597794]
             [  2.71190993 -25.49365577]
             [-47.37858268 -38.02120912]
             [-42.36990935  -6.0258027 ]
             [-16.00097294 -14.43926499]
             [ -0.822856   -13.7001301 ]
             [ -5.42741864 -18.56462272]
             [-13.80800193 -28.51385518]]
        '''
        return Z


if __name__ == '__main__':
    '10样本3特征(维度)的样本集, 行为样例，列为特征维度'
    X = np.array([[10, 15, 29],
                  [15, 46, 13],
                  [23, 21, 30],
                  [11, 9, 35],
                  [42, 45, 11],
                  [9, 48, 5],
                  [11, 21, 14],
                  [8, 5, 15],
                  [11, 12, 21],
                  [21, 20, 25]])
    K = np.shape(X)[1] - 1  # 输出 width,获取图像的宽 3  3-1=2 三维度降维成2维度
    print('样本集(10行3列，10个样例，每个样例3个特征):\n', X)
    pca = CPCA(X, K)



""""
numpy.mean()函数的语法格式如下：
    numpy.mean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)
    参数说明：
        a: 数组，用于计算平均值的Numpy数组。
        axis: 用于统计的轴（0表示列，1表示行）。
        dtype: 用于计算的数据类型，若不指定，则使用默认数据类型。
        out: 输出结果的Numpy对象。
        keepdims: 是否保留原来数组的维度。
        where: 可选参数，布尔型数组，可以用来排除某些元素的计算。
    返回值：
        numpy.mean()函数返回Numpy对象，表示数组元素的平均值。若axis参数被指定，则返回一个Numpy数组，表示沿着轴元素的平均值。
        例如，如果 attr 是一个包含 [1, 2, 3, 4, 5] 的数组，那么 np.mean(attr) 将返回这些数的平均值，即 3.0。

    
numpy.array()函数的语法格式如下：   
numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)  作用：创建一个数组。
    参数说明：
        object:  数组 公开数组接口的任何对象，__array__方法返回数组的对象，或任何（嵌套）序列。
        dtype ： 数据类型，可选  数组所需的数据类型。如果没有给出，那么类型将被确定为保持序列中的对象所需的最小类型。此参数只能用于“upcast”数组。
                              对于向下转换，请使用.astype(t)方法。
        copy ： bool，可选     如果为true（默认值），则复制对象。否则，只有当__array__返回副本，obj是嵌套序列，
                              或者需要副本来满足任何其他要求（dtype，顺序等）时，才会进行复制。
        order ： {'K'，'A'，'C'，'F'}，可选  指定阵列的内存布局。如果object不是数组，则新创建的数组将按C顺序排列（行主要），
                                          除非指定了'F'，在这种情况下，它将采用Fortran顺序（专业列）。如果object是一个数组，则以下成立。
        当copy=False出于其他原因而复制时，结果copy=True与对A的一些例外情况相同，请参阅“注释”部分。默认顺序为“K”。
        subok ： bool，可选   如果为True，则子类将被传递，否则返回的数组将被强制为基类数组（默认）。
        ndmin ： int，可选    指定结果数组应具有的最小维数。根据需要，将根据需要预先设置形状。
   
    返回值：out:ndarray 满足要求的数组对象
    
    
    
np.dot()函数主要有两个功能，向量点积和矩阵乘法，这里我就简单列举了三种最常用到的情况
    1. np.dot(a, b), 其中a为一维的向量，b为一维的向量，当然这里a和b都是np.ndarray类型的, 此时因为是一维的所以是向量点积。
            a = np.array([1, 2, 3, 4, 5])
            b = np.array([6, 7, 8, 9, 10])
            print(np.dot(a, b)) 
            output:
            130
    2. np.dot(a, b), 其中a为二维矩阵，b为一维向量，这时b会被当做一维矩阵进行计算
            a = np.random.randint(0,10, size = (5,5))
            b = np.array([1,2,3,4,5])
            print("the shape of a is " + str(a.shape))
            print("the shape of b is " + str(b.shape))
            print(np.dot(a, b))
            output:
            the shape of a is (5, 5)
            the shape of b is (5,)
            [42 85 50 81 76]
             需要注意的是一维矩阵和一维向量的区别，一维向量的shape是(5, ), 而一维矩阵的shape是(5, 1), 若两个参数a和b都是一维向量则是计算的点积，
             但是当其中有一个是矩阵时（包括一维矩阵），dot便进行矩阵乘法运算。所以如果是一个向量和一个矩阵相乘，这个向量会自动转换为一维矩阵进行计算。
    3. np.dot(a ,b), 其中a和b都是二维矩阵，此时dot就是进行的矩阵乘法运算
            a = np.random.randint(0, 10, size = (5, 5))
            b = np.random.randint(0, 10, size = (5, 3))
            print("the shape of a is " + str(a.shape))
            print("the shape of b is " + str(b.shape))
            print(np.dot(a, b))
            output:
            the shape of a is (5, 5)
            the shape of b is (5, 3)
            [[ 66  80  98]
             [ 53  60  60]
             [ 65  84  85]
             [ 25 113 101]
             [ 42  78  77]]

"""
